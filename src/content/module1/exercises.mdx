---
title: "Module 1 Exercises: The Robotic Nervous System (ROS 2)"
description: "Chapter problems and projects for Module 1"
---

# Module 1 Exercises: The Robotic Nervous System (ROS 2)

## Exercise 1.1: ROS 2 Node Communication

**Objective:** Implement a ROS 2 publisher and subscriber to understand basic node communication.

### Problem
Create a ROS 2 publisher that periodically publishes joint position data for a simple 2-DOF robot arm. The publisher should send messages of type `sensor_msgs/JointState`. Create a subscriber that receives these messages and logs the received data.

### Implementation Requirements
1. Define a publisher node that sends joint positions every 500ms
2. Use `std_msgs/Header`, and define joint names, positions, velocities, and efforts
3. Create a subscriber node that logs the received joint state information
4. Use appropriate ROS 2 message types from `sensor_msgs`

### Starter Code
```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState

class JointStatePublisher(Node):
    def __init__(self):
        super().__init__('joint_state_publisher')
        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        
    def timer_callback(self):
        # TODO: Create and publish JointState message
        pass

def main(args=None):
    rclpy.init(args=args)
    node = JointStatePublisher()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Stopping joint state publisher...')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Solution
```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
import math

class JointStatePublisher(Node):
    def __init__(self):
        super().__init__('joint_state_publisher')
        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0
        
    def timer_callback(self):
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = "base_link"
        
        # Define joint names
        msg.name = ["joint1", "joint2"]
        
        # Define joint positions (oscillating for demonstration)
        msg.position = [
            math.sin(self.i * 0.1) * 1.57,  # Joint 1: -90° to +90° range
            math.cos(self.i * 0.15) * 0.785 # Joint 2: -45° to +45° range
        ]
        
        # Define velocities and efforts (optional)
        msg.velocity = [0.0, 0.0]
        msg.effort = [0.0, 0.0]
        
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: {msg.position}')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    node = JointStatePublisher()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Stopping joint state publisher...')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Exercise 1.2: ROS 2 Service Implementation

**Objective:** Understand the request-response model in ROS 2 using services.

### Problem
Implement a ROS 2 service that calculates the forward kinematics for a simple 2-DOF planar manipulator. The service should accept joint angles and return the end-effector position.

### Service Definition
Create a service file `ForwardKinematics.srv`:
```
float64[] joint_angles  # Joint angles in radians
---
float64[] position      # End-effector position [x, y]
bool success            # Whether the calculation was successful
string message          # Error message if calculation failed
```

### Implementation Requirements
1. Implement a service server that calculates forward kinematics
2. Validate input joint angles (ensure they're within physical limits)
3. Implement client node that calls the service with different joint angles

### Mathematical Model
For a 2-DOF planar manipulator with link lengths L1 and L2:
- x = L1*cos(θ1) + L2*cos(θ1+θ2)
- y = L1*sin(θ1) + L2*sin(θ1+θ2)

### Solution
Server implementation:
```python
import rclpy
from rclpy.node import Node
from your_package.srv import ForwardKinematics  # Replace with actual package name
import math

class FKService(Node):
    def __init__(self):
        super().__init__('fk_service')
        self.srv = self.create_service(
            ForwardKinematics, 
            'forward_kinematics', 
            self.forward_kinematics_callback
        )
        # Link lengths
        self.l1 = 1.0  # Length of first link
        self.l2 = 0.8  # Length of second link
        
    def forward_kinematics_callback(self, request, response):
        try:
            # Validate input
            if len(request.joint_angles) != 2:
                response.success = False
                response.message = "Expected exactly 2 joint angles"
                response.position = []
                return response
                
            theta1, theta2 = request.joint_angles
            
            # Calculate end-effector position
            x = self.l1 * math.cos(theta1) + self.l2 * math.cos(theta1 + theta2)
            y = self.l1 * math.sin(theta1) + self.l2 * math.sin(theta1 + theta2)
            
            response.position = [x, y]
            response.success = True
            response.message = "Forward kinematics calculated successfully"
            
            self.get_logger().info(f'FK: Joints {theta1:.3f}, {theta2:.3f} -> Position {x:.3f}, {y:.3f}')
            
        except Exception as e:
            response.success = False
            response.message = f"Error in forward kinematics calculation: {str(e)}"
            response.position = []
        
        return response

def main(args=None):
    rclpy.init(args=args)
    node = FKService()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down FK service...')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Exercise 1.3: ROS 2 Action Server Implementation

**Objective:** Implement a time-intensive action that can be monitored and canceled.

### Problem
Create an action server that simulates a robot arm moving to a specified joint configuration. The action should provide feedback on progress and allow cancellation.

### Action Definition
Create an action file `MoveToJointPosition.action`:
```
# Goal: Target joint positions
float64[] target_positions

# Result: Success or failure
bool success
string message

# Feedback: Current progress
float64[] current_positions
float64[] target_positions
float64 remaining_time
```

### Implementation Requirements
1. Create action server that simulates joint movement
2. Provide feedback on current progress
3. Allow action to be canceled
4. Implement action client that sends goals and monitors progress

### Solution
Server implementation:
```python
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from your_package.action import MoveToJointPosition  # Replace with actual package
import time
import math

class MoveToJointPositionActionServer(Node):
    def __init__(self):
        super().__init__('move_to_joint_position_action_server')
        self._action_server = ActionServer(
            self,
            MoveToJointPosition,
            'move_to_joint_position',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback
        )

    def goal_callback(self, goal_request):
        # Accept all goals
        self.get_logger().info('Received goal request')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        # Accept all cancel requests
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    async def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')
        
        # Get the target positions from the goal
        target_positions = goal_request.target_positions
        current_positions = [0.0, 0.0]  # Starting position
        
        # Simulate the movement
        steps = 50  # Number of steps for the simulation
        for i in range(steps):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                result = MoveToJointPosition.Result()
                result.success = False
                result.message = "Goal was canceled"
                return result
                
            # Simulate movement progress
            progress = i / float(steps)
            for j in range(len(current_positions)):
                if j < len(target_positions):
                    current_positions[j] = current_positions[j] + \
                        (target_positions[j] - current_positions[j]) * progress
            
            # Publish feedback
            feedback_msg = MoveToJointPosition.Feedback()
            feedback_msg.current_positions = current_positions
            feedback_msg.target_positions = target_positions
            feedback_msg.remaining_time = (steps - i) * 0.2  # Estimate remaining time
            
            goal_handle.publish_feedback(feedback_msg)
            
            # Sleep to simulate real movement time
            time.sleep(0.2)
        
        # Check if goal was canceled during execution
        if goal_handle.is_cancel_requested:
            goal_handle.canceled()
            self.get_logger().info('Goal canceled')
            result = MoveToJointPosition.Result()
            result.success = False
            result.message = "Goal was canceled"
            return result

        # Complete the goal
        goal_handle.succeed()
        
        # Populate result message
        result = MoveToJointPosition.Result()
        result.success = True
        result.message = "Successfully moved to target joint positions"
        
        self.get_logger().info('Goal succeeded')
        return result

def main(args=None):
    rclpy.init(args=args)
    action_server = MoveToJointPositionActionServer()
    
    try:
        rclpy.spin(action_server)
    except KeyboardInterrupt:
        action_server.get_logger().info('Interrupted by user')
    finally:
        action_server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Exercise 1.4: URDF Robot Model Creation

**Objective:** Create a URDF model for a simple humanoid robot with ROS 2 integration.

### Problem
Design a URDF file for a simplified humanoid robot with a pelvis, two legs, and two arms. Include visual, collision, and inertial properties. Then create a ROS 2 launch file to spawn the robot in Gazebo and visualize it in RViz.

### Implementation Requirements
1. Create a URDF file with appropriate link and joint definitions
2. Include visual and collision geometry for each link
3. Define mass and inertial properties for physical simulation
4. Create a launch file that loads the robot and publishes TF transforms

### Solution
Basic URDF (`simple_humanoid.urdf`):
```xml
<?xml version="1.0"?>
<robot name="simple_humanoid">
  <!-- Material definitions -->
  <material name="blue">
    <color rgba="0 0 1 1"/>
  </material>
  <material name="red">
    <color rgba="1 0 0 1"/>
  </material>
  <material name="white">
    <color rgba="1 1 1 1"/>
  </material>

  <!-- Base/Pelvis link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.3 0.2 0.1"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <geometry>
        <box size="0.3 0.2 0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="10.0"/>
      <inertia ixx="0.4" ixy="0.0" ixz="0.0" iyy="0.3" iyz="0.0" izz="0.2"/>
    </inertial>
  </link>

  <!-- Head -->
  <joint name="neck_joint" type="revolute">
    <parent link="base_link"/>
    <child link="head_link"/>
    <origin xyz="0 0 0.15" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.5" upper="0.5" effort="10" velocity="1"/>
  </joint>

  <link name="head_link">
    <visual>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
      <material name="blue"/>
    </visual>
    <collision>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="2.0"/>
      <inertia ixx="0.008" ixy="0.0" ixz="0.0" iyy="0.008" iyz="0.0" izz="0.008"/>
    </inertial>
  </link>

  <!-- Left Hip -->
  <joint name="left_hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="left_thigh_link"/>
    <origin xyz="0 -0.1 -0.1" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>
  </joint>

  <link name="left_thigh_link">
    <visual>
      <geometry>
        <cylinder length="0.5" radius="0.05"/>
      </geometry>
      <material name="blue"/>
    </visual>
    <collision>
      <geometry>
        <cylinder length="0.5" radius="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="3.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.001"/>
    </inertial>
  </link>

  <!-- Right Hip -->
  <joint name="right_hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="right_thigh_link"/>
    <origin xyz="0 0.1 -0.1" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>
  </joint>

  <link name="right_thigh_link">
    <visual>
      <geometry>
        <cylinder length="0.5" radius="0.05"/>
      </geometry>
      <material name="blue"/>
    </visual>
    <collision>
      <geometry>
        <cylinder length="0.5" radius="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="3.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.001"/>
    </inertial>
  </link>
</robot>
```

## Exercise 1.5: ROS 2 Parameter Management

**Objective:** Implement parameter server for robot configuration with dynamic reconfiguration.

### Problem
Create a ROS 2 node that manages robot parameters such as joint limits, PID controller gains, and safety thresholds. Implement dynamic parameter reconfiguration that allows parameters to be changed at runtime.

### Implementation Requirements
1. Define parameters for robot configuration
2. Implement parameter validation
3. Allow parameters to be changed dynamically at runtime
4. Publish parameter changes to relevant nodes

### Solution
```python
import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rclpy.qos import QoSProfile
from std_msgs.msg import String

class RobotParameterManager(Node):
    def __init__(self):
        super().__init__('robot_parameter_manager')
        
        # Declare parameters with defaults
        self.declare_parameter('max_velocity', 1.0)
        self.declare_parameter('max_acceleration', 2.0)
        self.declare_parameter('safety_distance', 0.5)
        self.declare_parameter('control_loop_rate', 100)
        self.declare_parameter('pid_kp', 10.0)
        self.declare_parameter('pid_ki', 1.0)
        self.declare_parameter('pid_kd', 0.1)
        
        # Publisher for parameter change notifications
        self.param_change_pub = self.create_publisher(String, 'parameter_changes', 10)
        
        # Timer to monitor parameter changes
        self.timer = self.create_timer(1.0, self.check_parameter_changes)
        
        # Store initial values
        self.stored_params = {}
        self.update_stored_params()
        
        self.get_logger().info('Robot Parameter Manager initialized')
    
    def check_parameter_changes(self):
        """Check for parameter changes and notify other nodes"""
        current_params = {}
        for param_name in ['max_velocity', 'max_acceleration', 'safety_distance', 
                          'control_loop_rate', 'pid_kp', 'pid_ki', 'pid_kd']:
            param = self.get_parameter(param_name)
            current_params[param_name] = param.value
        
        # Check if any parameter changed
        for param_name, new_value in current_params.items():
            if param_name in self.stored_params:
                old_value = self.stored_params[param_name]
                if old_value != new_value:
                    self.get_logger().info(f'Parameter {param_name} changed from {old_value} to {new_value}')
                    
                    # Publish notification
                    msg = String()
                    msg.data = f"PARAMETER_CHANGE: {param_name}={new_value}"
                    self.param_change_pub.publish(msg)
        
        # Update stored parameters
        self.update_stored_params()
    
    def update_stored_params(self):
        """Update the stored parameter values"""
        for param_name in ['max_velocity', 'max_acceleration', 'safety_distance', 
                          'control_loop_rate', 'pid_kp', 'pid_ki', 'pid_kd']:
            param = self.get_parameter(param_name)
            self.stored_params[param_name] = param.value

def main(args=None):
    rclpy.init(args=args)
    node = RobotParameterManager()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down parameter manager...')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

---

## Project 1: ROS 2 Robot Control System

**Objective:** Design and implement a complete ROS 2-based control system for a simulated robot.

### Requirements
1. Create nodes for different robot subsystems (navigation, manipulation, perception)
2. Implement communication between nodes using topics, services, and actions
3. Use launch files to start all nodes together
4. Include parameter management and dynamic reconfiguration
5. Add a simple GUI or command-line interface for robot control

### Implementation Steps
1. Design the architecture with all required nodes
2. Implement each node with proper interfaces
3. Create launch files for different configurations
4. Test the system in simulation
5. Document the system architecture and interfaces

### Evaluation Criteria
- Proper use of ROS 2 communication patterns
- Modularity and separation of concerns
- Quality of documentation
- Robustness to parameter changes and node failures
- Performance and efficiency