---
title: "Module 2: The Digital Twin (Gazebo & Unity)"
description: "Physics simulation and environment building for humanoid robotics"
---


# Module 2: The Digital Twin (Gazebo & Unity)

## Learning Objectives

By the end of this module, students will be able to:
1. Set up and configure Gazebo simulation environments
2. Create robot models using URDF and SDF formats
3. Simulate physical interactions including gravity, collisions, and contacts
4. Develop Unity environments for robot visualization
5. Simulate various sensor types (LiDAR, cameras, IMUs)

## Key Terms

- **Gazebo**: A physics-based simulation environment that provides realistic sensor simulation and contact dynamics
- **URDF**: Unified Robot Description Format, an XML format for representing robot models
- **SDF**: Simulation Description Format, Gazebo's native format for representing objects and environments
- **Digital Twin**: A virtual replica of a physical system that simulates its behavior
- **Sensor Simulation**: The process of modeling sensor outputs based on virtual world state

## 2.1 Introduction to Physics Simulation

Physics simulation is a cornerstone of modern robotics development, allowing engineers to test control algorithms, sensor configurations, and robot designs in a safe, repeatable environment. In the context of humanoid robotics, accurate simulation is particularly important due to the complex dynamics involved in bipedal locomotion and the high cost of physical prototyping.

### Core Physics Concepts in Simulation

The simulation of humanoid robots involves several fundamental physics concepts:

- **Rigid Body Dynamics**: The simulation of objects that do not deform under applied forces
- **Collision Detection**: Determining when and where objects in the simulation make contact
- **Contact Physics**: Modeling the forces and responses when objects interact
- **Constraints**: Mathematical relationships that limit the motion of objects

### Mathematical Foundation

The core of rigid body simulation is solving Newton's equations of motion for each body in the simulation:

```
F = ma
τ = Iα
```

Where F is the net force acting on the body, m is its mass, a is its linear acceleration, τ is the net torque, I is the moment of inertia, and α is the angular acceleration.

For articulated systems (like robots), these equations become more complex and involve the Jacobian matrix J and mass matrix M:

```
M(q)q̈ + C(q, q̇)q̇ + G(q) = τ + J^T(q)F
```

Where q represents joint coordinates, C represents Coriolis and centrifugal forces, G represents gravitational forces, τ represents joint torques, and F represents external forces.

## 2.2 Gazebo Simulation Environment

Gazebo is a powerful, open-source physics simulator that provides realistic simulation of robots in complex environments. It offers:

- Accurate rigid body dynamics
- SDF-based world and model descriptions
- Extensive sensor simulation
- Realistic rendering
- Plugins for custom behaviors

### Setting Up Gazebo

Gazebo comes with ROS2 distributions and can be installed separately. To start Gazebo with a basic empty world:

```bash
# Start Gazebo server
gz sim -s

# Or use the legacy command
gazebo --verbose
```

:::tip[Gazebo Resources]
Gazebo has transitioned from the legacy libgazebo API to the newer Ignition Gazebo (now called Gazebo Garden or newer versions). Make sure to check the version-specific documentation for your installation.
:::

### Creating a Simulation World

A Gazebo world is described using SDF (Simulation Description Format). Here's a basic example:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_world">
    <!-- Include a ground plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>
    
    <!-- Include a sun for lighting -->
    <include>
      <uri>model://sun</uri>
    </include>
    
    <!-- Add a simple box obstacle -->
    <model name="obstacle">
      <pose>2 0 0.5 0 0 0</pose>
      <link name="link">
        <visual name="visual">
          <geometry>
            <box>
              <size>0.5 0.5 1.0</size>
            </box>
          </geometry>
        </visual>
        <collision name="collision">
          <geometry>
            <box>
              <size>0.5 0.5 1.0</size>
            </box>
          </geometry>
        </collision>
        <inertial>
          <mass>1.0</mass>
          <inertia>
            <ixx>0.0833</ixx>
            <iyy>0.0833</iyy>
            <izz>0.0833</izz>
          </inertia>
        </inertial>
      </link>
    </model>
  </world>
</sdf>
```

## 2.3 Robot Description with URDF and SDF

Robots in simulation need detailed descriptions of their physical properties, including kinematic structure, inertial properties, and visual/collision geometry.

### URDF vs SDF

- **URDF (Unified Robot Description Format)**: Primarily used for kinematic and geometric description, widely adopted in ROS/ROS2
- **SDF (Simulation Description Format)**: Gazebo's native format, includes physics and simulation-specific properties

### URDF Example for Humanoid Robot

```xml
<?xml version="1.0"?>
<robot name="simple_humanoid">
  <!-- Base/Pelvis link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.3 0.2 0.1"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.3 0.2 0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="10.0"/>
      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>
    </inertial>
  </link>

  <!-- Example leg link -->
  <joint name="hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="thigh_link"/>
    <origin xyz="0 -0.1 -0.2" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>
  </joint>

  <link name="thigh_link">
    <visual>
      <geometry>
        <cylinder length="0.5" radius="0.05"/>
      </geometry>
      <material name="red">
        <color rgba="1 0 0 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder length="0.5" radius="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="2.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.005"/>
    </inertial>
  </link>
</robot>
```

## 2.4 Physics Simulation in Gazebo

Accurate physics simulation is critical for effective robot development. Key parameters that affect simulation quality include:

### Contact Parameters

```xml
<!-- In SDF model definition -->
<collision name="collision">
  <surface>
    <contact>
      <ode>
        <kp>10000000</kp>  <!-- Contact stiffness -->
        <kd>1</kd>          <!-- Damping coefficient -->
        <max_vel>100</max_vel>
        <min_depth>0.001</min_depth>
      </ode>
    </contact>
    <friction>
      <ode>
        <mu>1.0</mu>      <!-- Friction coefficient -->
        <mu2>1.0</mu2>
      </ode>
    </friction>
  </surface>
</collision>
```

### Inertial Properties

Accurate inertial properties are crucial for stable simulation:

- Mass: Should match the actual robot as closely as possible
- Center of Mass: Should be at the correct location relative to the link frame
- Inertia Matrix: Should reflect the 3D distribution of mass

## 2.5 Sensor Simulation

Gazebo provides simulation of various sensor types that are common in humanoid robots:

### IMU Simulation

```xml
<sensor name="imu_sensor" type="imu">
  <always_on>true</always_on>
  <update_rate>100</update_rate>
  <topic>imu/data</topic>
  <visualize>true</visualize>
</sensor>
```

### Camera Simulation

```xml
<sensor name="camera" type="camera">
  <camera name="head">
    <horizontal_fov>1.047</horizontal_fov>
    <image>
      <width>640</width>
      <height>480</height>
      <format>R8G8B8</format>
    </image>
    <clip>
      <near>0.1</near>
      <far>100</far>
    </clip>
  </camera>
  <always_on>true</always_on>
  <update_rate>30</update_rate>
  <visualize>true</visualize>
</sensor>
```

### LiDAR Simulation

```xml
<sensor name="laser" type="ray">
  <ray>
    <scan>
      <horizontal>
        <samples>640</samples>
        <resolution>1</resolution>
        <min_angle>-1.570796</min_angle>
        <max_angle>1.570796</max_angle>
      </horizontal>
    </scan>
    <range>
      <min>0.1</min>
      <max>30.0</max>
      <resolution>0.01</resolution>
    </range>
  </ray>
  <plugin name="laser_control" filename="libgazebo_ros_ray_sensor.so">
    <ros>
      <argument>~/out:=scan</argument>
    </ros>
    <output_type>sensor_msgs/LaserScan</output_type>
  </plugin>
</sensor>
```

## 2.6 Unity Integration for Visualization

While Gazebo provides physics simulation, Unity can offer high-quality visualization and rendering for more realistic perception training. Unity can be connected to ROS2 using various bridge solutions:

- **Unity Robotics Hub**: Official package for ROS/Unity integration
- **ROS#**: A .NET ROS client library for Unity
- **Custom TCP/IP bridges**: For specific use cases

### Unity ROS Integration Setup

The Unity Robotics Hub provides several key components:

- **ROS Connection**: Manages TCP connection to ROS network
- **Message Extensions**: Pre-built components for common ROS message types
- **Sensor Publishing**: For streaming Unity sensor data to ROS
- **Actuator Subscriptions**: For controlling Unity objects from ROS

## 2.7 Simulation Best Practices

### Validation of Simulation

To ensure your simulation accurately represents the real robot:

1. **Compare kinematic behavior**: Verify forward and inverse kinematics match
2. **Validate dynamic properties**: Compare simulation responses to real robot data when available
3. **Test sensor models**: Ensure simulated sensors behave like real counterparts

### Simulation Fidelity Considerations

The "reality gap" between simulation and reality can impact sim-to-real transfer:

- **Visual fidelity**: Textures, lighting, and rendering quality affect perception systems
- **Dynamics fidelity**: Mass distribution, friction, and contact modeling affect control systems
- **Sensor fidelity**: Noise models and systematic errors should match real sensors

:::note[Sim-to-Real Transfer]
Research has shown that domain randomization—introducing random variations in simulation parameters—can help improve sim-to-real transfer by making systems robust to model inaccuracies.
:::

## 2.8 Practical Exercise: Creating a Simple Humanoid Model

In this exercise, you will create a simplified humanoid model in URDF, spawn it in Gazebo, and verify its basic physics properties.

### Steps:

1. Create a URDF file for a simple humanoid with a pelvis, legs, and arms
2. Add appropriate inertial properties
3. Spawn the model in Gazebo
4. Apply simple forces to test physics response
5. Add an IMU sensor and visualize its output

---

## Discussion Questions

1. What are the advantages and limitations of physics simulation for humanoid robotics development?
2. How do URDF and SDF differ in their approach to robot description?
3. Why is accurate inertial modeling important for humanoid robot simulation?
4. What factors contribute to the "reality gap" between simulation and real robots?
5. How can simulation be used to validate control algorithms before physical testing?

## Practical Exercises

### Exercise 1: URDF Model Creation
Create a URDF file for a simplified humanoid robot with at least 10 degrees of freedom. Include appropriate visual, collision, and inertial properties.

### Exercise 2: Gazebo World Development
Design a Gazebo world with obstacles and terrain features appropriate for testing humanoid locomotion.

### Exercise 3: Sensor Integration
Add at least three different sensor types to your humanoid model and verify their functionality in simulation.

## References

1. Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. *IEEE/RSJ International Conference on Intelligent Robots and Systems*, 2350-2354.
2. Bohren, J., & Cousins, S. (2013)._ros: an open-source graphical front end for robot development. *IEEE International Conference on Robotics and Automation*, 3160-3166.
3. Tedrake Lab. (2023). Underactuated Robotics: Algorithms for Walking, Running, Swimming, Flying, and Manipulation. MIT Press.
4. Coumans, E., & Bai, Y. (2016). Mujoco: A physics engine for model-based control. *IEEE/RSJ International Conference on Intelligent Robots and Systems*.
5. OpenRAVE community. (2010). OpenRAVE: A planning architecture for autonomous robotics. *IEEE Transactions on Automation Science and Engineering*.
6. Unity Technologies. (2023). Unity Robotics Hub Documentation.
7. ROS-Unity Integration Working Group. (2023). ROS# Documentation.